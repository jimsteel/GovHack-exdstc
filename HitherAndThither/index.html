<html>
<title>Hither and Thither</title>

<script src="d3/d3.v3.min.js"></script>
<script src="d3/topojson.v1.min.js"></script>
<script src="js/datamaps.world.min.js"></script>
<h1>Hither and Thither: <span id="date">None</span></h1>
<table width="600"><tr>
<td>
  <input type="radio" name="direction" id="departureDir" value="Departures" checked>Departures
  <input type="radio" name="direction" id="arrivalDir" value="Arrivals">Arrivals
<td>
  <input type="radio" name="period" id="monthP" value="Month">Months
  <input type="radio" name="period" id="allP" value="Both" checked>Months &amp; Years
  <input type="radio" name="period" id="yearP" value="Year">Years
</table>
<div id="container" style="position: relative; width: 95%; height: 80%;">
</div>
<script>

var ausLat = [-25.27439, 133.775136],
  map = new Datamap({
  element: document.getElementById('container'),
  projection: 'mercator',
  setProjection: function(element, options) {
            var projection, path;
            projection = d3.geo.mercator()
                //.center([125, 0])
                //.scale(element.offsetWidth)
                .rotate([-160,5])
                //.translate([element.offsetWidth / 2, element.offsetHeight / 2])
;

            path = d3.geo.path()
                .pointRadius(2)
                .projection( projection );

            return {path: path, projection: projection};
        },
  fills: { defaultFill: '#ABDDA4', "bubble": "#1ff", "x": "#f1f" },
  geographyConfig: {
        dataUrl: null, //if not null, datamaps will fetch the map JSON (currently only supports topojson)
        hideAntarctica: false,
        borderWidth: 1,
        borderColor: '#FDFDFD',
        popupTemplate: function(geography, data) { //this function should just return a string
          return '<div class="hoverinfo"><strong>' + geography.properties.name + '</strong></div>';
        },
        popupOnHover: true, //disable the popup while hovering
        highlightOnHover: true,
        highlightFillColor: '#FC8D59',
        highlightBorderColor: 'rgba(250, 15, 160, 0.2)',
        highlightBorderWidth: 2
    },
  bubbleConfig: {
        borderWidth: 2,
        borderColor: '#FFFFFF',
        popupOnHover: false,
        popupTemplate: function(geography, data) {
          return '<div class="hoverinfo"><strong>' + data.name + '</strong></div>';
        },
        fillOpacity: 0.75,
        highlightOnHover: true,
        highlightFillColor: '#FC8D59',
        highlightBorderColor: 'rgba(250, 15, 160, 0.2)',
        highlightBorderWidth: 2,
        highlightFillOpacity: 0.85
    }
});

var dd = d3.select("#date");

var g = d3.select("svg").append("g");

function computeYearly(months) {
  var years = [], currentY = "", totals, count = 0;

  months.forEach(function (m) {
    var y = m.month.substr(4);

    if (currentY != y) {
      if (typeof totals !== "undefined") { normalise(totals, count); years.push(totals); }
      totals = {"month": y};
      count = 0;
      currentY = y;
    }

    Object.keys(m)
      .filter(function (k) { return "month" !== k; })
      .forEach(function (k) {
        totals[k] = parseInt(m[k]) + (totals[k] || 0);
      });
    count++;
  });

  normalise(totals, count);
  years.push(totals);

  return years;
}

function computeMonthly(months) {
  var lbls = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  var monthly = [], currentM = "", totals={}, count = {};

  lbls.forEach(function(l) {
    totals[l] = {month: l};
    count[l] = 0;
  });

  months.forEach(function (m) {
    var l = m.month.substr(0,3);

    Object.keys(m)
      .filter(function (k) { return "month" !== k; })
      .forEach(function (k) {
        totals[l][k] = parseInt(m[k]) + (totals[l][k] || 0);
      });
    count[l]++;
  });

  lbls.forEach(function(l) {
    normalise(totals[l], count[l]);
    monthly.push(totals[l]);
  });

  return monthly;
}

function normalise(totals, count) {
  Object.keys(totals)
    .filter(function (k) { return "month" !== k; })
    .forEach(function (k) {
      totals[k] = totals[k] / count;
    });
}

function getPeriod() {
  var result = 1;

  if (mP = document.getElementById("monthP").checked) { result = 0; }
  if (yP = document.getElementById("yearP").checked) { result = 2; }
  
  return result;
}

d3.csv('data/countries.csv', function(error, csvData) {
  d3.csv('data/340105.csv', function(error, arrivalsMonths) {
    d3.csv('data/340109.csv', function(error, departuresMonths) {
      var arrivalsYears = computeYearly(arrivalsMonths);
      var departuresYears = computeYearly(departuresMonths);

      var inputData = [
        [computeMonthly(arrivalsMonths), computeMonthly(departuresMonths)],
        [arrivalsMonths, departuresMonths],
        [arrivalsYears, departuresYears]
      ];

      d3.selectAll("input").on("change", function () {
        var p = getPeriod();
        var arrivals = document.getElementById("arrivalDir").checked;
        process(csvData, arrivals ? inputData[p][0] : inputData[p][1], arrivals);
      });

      var p = getPeriod();
      var arrivals = document.getElementById("arrivalDir").checked;
      process(csvData, arrivals ? inputData[p][0] : inputData[p][1], arrivals);
    })
  })
})

function process(csvData, months, arrivals) {
  var countries = csvData
    .filter(function (c) {
      return typeof months[0][c.country] !== "undefined" && c.country.indexOf("Total") < 0 && c.country.indexOf("Other") < 0;
    }),
    aus = map.latLngToXY(ausLat[0], ausLat[1]);

  countries
    .forEach(function (c) {
      var coord = map.latLngToXY(c.latitude,c.longitude);
      c.x = coord[0];
      c.y = coord[1];
    });

/*
  var pp = g.selectAll(".route")
    .data(countries, function(c,i) { if (c) {return c.country;}else{console.log(i); return c;} })
    .enter()
      .append("path")
        .attr("class", "route")
        .attr("stroke", "#1f1")
        .attr("stroke-width", 20)
        .attr("d", function(c) { return "M "+aus[0]+" "+aus[1]+" L "+c.x+" "+c.y; });
*/

  var bub = g.selectAll(".bub")
    .data(countries, function(c,i) { return c.country; });

  bub.interrupt().transition();

  bub
    .enter()
      .append("circle")
      .attr("class", "bub")
      .attr("cx", function (c) { return c.x; })
      .attr("cy", function (c) { return c.y; })
      .attr("opacity", 0.7)
      .attr("stroke", "white")
      .attr("stroke-width", 2)
      .attr("r", 0)
      .style("fill", "#f1f")
      .each(function () { d3.select(this).append("title").text(function(c) { return c.country; }) });

  bub.exit()
    .each(function(d) {console.log(d.country);})
    .remove();

  var fly = g.selectAll(".fly")
    .data(countries, function(c,i) { return c.country; });

  fly.interrupt().transition();

  fly
    .enter()
      .append("circle")
      .attr("class", "fly")
      .attr("cx", aus[0])
      .attr("cy", aus[1])
      .attr("opacity", 0.7)
      .attr("stroke", "black")
      .attr("stroke-width", 1)
      .attr("r", 5)
      .style("fill", "#1ff");
  fly.exit()
    .remove();

  var flyTime = 1000, growTime = 1000, resetTime = 100, time = resetTime+flyTime+growTime, delta = 1;

  months
    .forEach(function (m, i) {
      // change month
      dd.transition()
        .delay(i*time)
        .text((arrivals ? "Inbound visitors in " : "Outbound Aussies in ") + m.month);

      // fly to destination
      fly.transition()
        .delay(resetTime+(i*time))
        .duration(flyTime)
        .attr("cx", function(d) { return arrivals ? aus[0] : d.x; })
        .attr("cy", function(d) { return arrivals ? aus[1] : d.y; })
        .attr("r", 3)
        .each("start", function () {
          // reset to Australia
          d3.select(this)
            .attr("r", 5)
            .attr("cx", function(d) { return arrivals ? d.x : aus[0]; })
            .attr("cy", function(d) { return arrivals ? d.y : aus[1]; });
        })
        .each("end", function () {
          // shrink at end
          d3.select(this)
            .attr("r", 2);
        });

      // fade destination
      bub.transition()
        .delay((i*time))
        .duration(flyTime)
        .attr("opacity", 0.1);

      // resize destination
      bub.transition()
        .delay(flyTime+(i*time))
        .duration(growTime)
        .attr("opacity", 0.7)
        .style("fill", function (d) {
          var thisSize = bsize(m[d.country]),
              prevSize = i == 0 ? thisSize : bsize(months[i-1][d.country]);
          if (thisSize / prevSize > 1.1) {
            return "#f11";
          } else if (thisSize / prevSize < 0.9) {
            return "#11f";
          } else {
            return "#ff1";
          }
        })
        .attr("r", function(d) { return bsize(m[d.country]); });

    })
}

function bsize(n) {
  return typeof n === "undefined" ? 0 : (n < 100000 ? Math.log(1+n)/Math.log(1.6) : 50);
}

</script>

